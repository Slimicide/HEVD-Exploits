# Stack Buffer Overflow - x64 Windows 10 22H2 (No SMEP)
![Exploit](https://github.com/Slimicide/HEVD-Exploits/blob/main/STACK_BUFFER_OVERFLOW/img/exploit.gif)

# Reverse Engineering
HEVD is completely open-source and has debug symbols available for download, but I undertook this project to build some confidence in black-box
reverse engineering with IDA and WinDBG considering that will be the case most of the time with other binaries.

When approaching Windows drivers, there are two points of immediate interest:
* **The device name** -> Required to open a handle to and interact with the driver.
* **The IOCTL dispatcher routine** -> Holds a list of functions that can be called by supplying their corresponding IOCTL code.

Every driver has an [EntryPoint](https://learn.microsoft.com/en-us/windows-hardware/drivers/wdf/driverentry-for-kmdf-drivers) routine that gets called every time a new driver gets loaded.

![DriverEntry](img/driverentry.PNG)

Inside this routine is the function that will initialize the driver and reveal the name of the device (function names changed for convenience).

![HEVD_Initialize](img/hevd_initialize.PNG)

In this screenshot, I have already identified and renamed the function responsible for dispatching calls to the driver with IOCTL codes but it is easy
to find yourself, at least in HEVD. 

HEVD annotates each valid IOCTL code with a string telling you what it does. Simply go to the `Strings` view in IDA,
find the description you're after and follow the single cross-reference to find it sitting in the IOCTL dispatcher.

![IOCTL Dispatcher String](img/ioctl_dispatcher_strings.PNG)
![IOCTL Dispacther Function](img/ioctl_dispatcher_function.PNG)

The `BUFFER_OVERFLOW_STACK` function exists under the IOCTL code `0x222003`.
This IOCTL code can now be used in a usermode function call to [DeviceIoControl](https://learn.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol)
in conjunction with a handle to the driver we can obtain using the driver's name discovered in the HEVD intialization function, allowing us to directly interact with the `BUFFER_OVERFLOW_STACK` function.

## The Bug
Inside the `BUFFER_OVERFLOW_STACK` function is another function I've named `BUFFER_OVERFLOW_STACK_EXECUTOR` that actually sets up the vulnerability.

The kernel buffer is initialized at a size of 2048 bytes (0x800) before it is sent off to a function I've called `BUFFER_OVERFLOW_STACK_CORRUPTOR` alongside our usermode buffer and usermode buffer size.

![usermode_buffer](img/usermode_buffer.PNG)

The bug occurs relatively early in this function. This function takes the address of the kernel buffer and adds it to the size of the usermode buffer without any
bounds checking or limitations on how big the usermode buffer can be. As we'll soon see `pKernPlusUserSize` holds the address that will be written to. 
It begins at the end and works back towards the top. There is nothing stopping it from being larger than the 0x800 bytes allocated for it, 
enabling it to overflow and overwrite unrelated data on the stack.

![Bug](img/bug.PNG)

To visualize this problem, take a scenario where the kernel buffer begins at address `0x0000` and the user buffer is `0x0900` in size:

![Diagram](img/diagram.PNG)

The part responsible for the actual writing is further down. It takes `pKernPlusUserSize`and fills the buffer until it has written `UserBufferSize` number of bytes.

![Overflow Function](img/overflow_function.PNG)

# The Exploit
Now that we have a strong understanding of the bug and how to trigger it, we can attach a kernel debugger to the development machine and experiment with different payloads.
Through this bug, we have the ability to overwrite anything we want on the stack. Typically the target would be hijacking the flow of execution by overwriting the current function's return address.

When a new function is called, a return address is pushed onto the stack so that once the called function concludes, it can use a `ret` (return) instruction to pop that return address back into the instruction
pointer to continue the flow of execution. By overwriting that return address, we can hijack execution to go wherever we want.

This time will be no different. The goal is the RIP register.

We can start by setting a breakpoint at the end of the corruptor function. At the time of writing, this can be achieved with `bp HEVD+13b1` in WinDBG.
Now, by sending 0x800 bytes of data to the overflow function, we can inspect the uncorrupted stack and find the return address to find out exactly how many bytes we need to exceed
the buffer by in order to overwrite the return address.

![0x800 Buffer](img/0x800_buffer.PNG)

This is what a full, intended buffer looks like. Nothing on the stack has been overwritten. Yet. We need to overflow the buffer by `0x20` bytes in order to overwrite the return address.
By sending another `0x18` bytes of junk followed by `0x8` bytes of an arbitrary address, we can verify that the return address is overwritten.

![0x820 Buffer](img/0x820_buffer.PNG)

Now the return address has been completely overwritten by `0xdeadbeefdeadbeef`. This address isn't in use and upon executing `ret` from this function, the machine should crash.

![Crash](img/rip_overwrite_crash.PNG)

As expected, we get an Access Violation caused by the execution of the `ret` instruction on a non-existent address.

But what address should it be?

## Shellcode and SMEP
We of course have the means to allocate our own chunk of memory by using functions such as [VirtualAlloc](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc).

By specifying we want this new allocation to be executable, we can safely overwrite the return address with the address of this new allocation and write instructions of our own for the kernel to execute.
Normally, there's a mitigation against doing exactly this called **Supervisor Mode Execution Protection** (SMEP)
SMEP exists to prevent a thread in kernel mode from executing instructions stored at a user mode address.
It's not too tricky to bypass, but for some reason my development virtual machine doesn't have SMEP enabled so I will proceed without the need for a SMEP bypass (at least for now).

A popular choice for kernel mode shellcode is token-stealing shellcode.
The purpose of this shellcode is to find the SYSTEM process (PID 4) and copy its access token (NT AUTHORITY\SYSTEM) onto the current process to spawn a free shell as the SYSTEM user.

For my exploit, I opted to modify [Connor McGarr](https://twitter.com/33y0re)'s token-stealing shellcode from his blogpost on 
[Kernel Mode Shellcode and Exploit Development](https://connormcgarr.github.io/x64-Kernel-Shellcode-Revisited-and-SMEP-Bypass/). Connor McGarr makes excellent blog posts on all sorts of different
exploit development topics and is mostly responsible for my interest in exploring the area.

Anyway, here is his unmodified shellcode:
```py
payload = bytearray(
    "\x65\x48\x8B\x04\x25\x88\x01\x00\x00"              # mov rax,[gs:0x188]  ; Current thread (KTHREAD)
    "\x48\x8B\x80\xB8\x00\x00\x00"                      # mov rax,[rax+0xb8]  ; Current process (EPROCESS)
    "\x48\x89\xC3"                                      # mov rbx,rax         ; Copy current process to rbx
    "\x48\x8B\x9B\xE8\x02\x00\x00"                      # mov rbx,[rbx+0x2e8] ; ActiveProcessLinks
    "\x48\x81\xEB\xE8\x02\x00\x00"                      # sub rbx,0x2e8       ; Go back to current process
    "\x48\x8B\x8B\xE0\x02\x00\x00"                      # mov rcx,[rbx+0x2e0] ; UniqueProcessId (PID)
    "\x48\x83\xF9\x04"                                  # cmp rcx,byte +0x4   ; Compare PID to SYSTEM PID
    "\x75\xE5"                                          # jnz 0x13            ; Loop until SYSTEM PID is found
    "\x48\x8B\x8B\x58\x03\x00\x00"                      # mov rcx,[rbx+0x358] ; SYSTEM token is @ offset _EPROCESS + 0x348
    "\x80\xE1\xF0"                                      # and cl, 0xf0        ; Clear out _EX_FAST_REF RefCnt
    "\x48\x89\x88\x58\x03\x00\x00"                      # mov [rax+0x358],rcx ; Copy SYSTEM token to current process
    "\x48\x83\xC4\x40"                                  # add rsp, 0x40       ; RESTORE (Specific to HEVD)
    "\xC3"                                              # ret                 ; Done!
)
```
